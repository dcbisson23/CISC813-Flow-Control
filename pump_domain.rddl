domain pump_flow_control {

	requirements = {
        continuous,
		concurrent,             // different reservoirs are controlled independently
		reward-deterministic,   // this domain does not use a stochastic reward
		intermediate-nodes,     // this domain uses intermediate pvariable nodes
		constrained-state      // this domain uses state constraints
        // partially-observed      // this domain relies on sensor data, making it partially-observable.
    };

	types {
        // To model the problem as a flow network, nodes in the network will be holding tanks. 
        node: object;

        // sensor-pressure: object;
        // Pressure sensors can be located at the start or end of an arc in the network.
        // sensor-loc: {@start, @end};

        //sensor-flow: object;
        //sensor-level: object;



        // Pumps will draw fluid from tank nodes into other nodes.
        // Pumps will act as controllers, as they move fluid through a system. The control variable is the speed of each pump!
        // Changing the speed of a pump has effects on both flow and pressure, which will need to be factored in.
        pump: object;
        // There are two main types of pumps, which have different operating constraints:
        // 1. Positive-displacement pumps move fixed volumes of fluid, so they are pressure-invariant.
        // The pressure and flow out of the pump at a given RPM will be independent of the input pressure (assuming sufficient feed pressure).
        // 2. Centrifugal pumps use an impeller to move fluid, so their throughput is more difficult to model.
        // The pressure and flow out of the pump at a given RPM will be dependent on the input pressure.
        pump-type: {@pd, @cf}; // TODO: Add @cf capability (will require pressure implementation).

	};

    pvariables {
		    // Constants

        // TODO: Add pressure control capability (related to pump curves).

        // Simulation constants for generating next-step sensor values
        POLLING-RATE: {non-fluent, real, default = 1.0}; // The time between state snapshots (s)
        PUMP-MAX-DELTA: {non-fluent, real, default = 10.0};

        // Variance values for flow/pressure sampling
        // PRESSURE-VARIANCE: {non-fluent, real, default = 1};
        FLOW-VARIANCE: {non-fluent, real, default = 1};

        FLOW-THRESHOLD: {non-fluent, real, default = 1.0};
        LEVEL-THRESHOLD: {non-fluent, real, default = 0.05};

        // PRESSURE-PENALTY: {non-fluent, real, default = -1.0};
        FLOW-PENALTY: {non-fluent, real, default = -1.0};
        LEVEL-PENALTY: {non-fluent, real, default = -1.0};

        OVERFLOW-BUFFER: {non-fluent, real, default = 0.95};

        SOURCE(pump, node): {non-fluent, bool, default = false};
        SINK(node, pump): {non-fluent, bool, default = false};

        // Nodes are connected by directed arcs. In this case, those arcs are pipes!
        CONNECTED(node, node): {non-fluent, bool, default = false};

        // Pumps can be either positive-displacement or centrifugal. 
        PUMP-TYPE(pump): {non-fluent, pump-type, default = @pd};
        // The displacement coefficient represents how many units of fluid are moved per revolution (m^3/revolution).
        PUMP-DISPLACEMENT(pump): {non-fluent, real, default = 1.0};
        // To preserve spatial context with respect to sensors, pumps will be located in the middle of an arc (before @start and before @end).
        // Pumps will induce flow between two nodes.
        DRAWS(pump, node, node): {non-fluent, bool, default = false};

        // Pressure sensors watch the pressure between two tanks. 
        // We'll want to be able to measure pressure at the start and end of an arc to calculate differential pressure.
        // SENSOR-PRESSURE(sensor-pressure, node, node, sensor-loc): {non-fluent, bool, default = false};
        // Flow sensors measure the volumetric flow rate between two tanks.
        //SENSOR-FLOW(sensor-flow, pump): {non-fluent, bool, default = false};
        // Level sensors watch the level within tanks.
        //SENSOR-LEVEL(sensor-level, node): {non-fluent, bool, default = false};
        
        // Some sensors will have target values the system needs to maintain. 

        // HAS-TARGET(sensor-pressure): {non-fluent, bool, default = false};
        // TARGET(sensor-pressure): {non-fluent, real, default = 0.0};

        HAS-TARGET-FLOW(pump): {non-fluent, bool, default = false};
        TARGET-FLOW(pump): {non-fluent, real, default = 0.0};
        HAS-TARGET-LEVEL(node): {non-fluent, bool, default = false};
        TARGET-LEVEL(node): {non-fluent, real, default = 0.0};

        // Tanks have a set fluid volume capacity (m^3). If the held fluid in the tank is too high or low, the system can break!
        CAPACITY(node): {non-fluent, real, default = 100.0};
        
            // Intermediate fluents

        inflow(node): {interm-fluent, real}; // The total flow into a node.
        outflow(node): {interm-fluent, real}; // The total flow out of a node.
        pump-hz-variance(pump): {interm-fluent, real};

            // State fluents

        pump-hz(pump): {state-fluent, real, default = 0.0}; // The current Hz of a pump; the main process variable.

        pump-flow(pump): {state-fluent, real, default = 0.0}; // The flow rate of fluid through a pump (carries through an entire arc!)
        
        // TODO: in and out-pressure CPFs
        // in-pressure(node, node): {state-fluent, real, default = 1.0};
        // out-pressure(node, node): {state-fluent, real, default = 1.0};

        holding(node): {state-fluent, real, default = 0.0}; // The amount of fluid being stored in the tank (m^3).

            // Observation fluents
        
        // Observations will be made by sensor objects.
        // pressure-obs(sensor-pressure): {observ-fluent, real};
        // flow-obs(pump): {observ-fluent, real};
        // level-obs(node): {observ-fluent, real};

            // Action fluents

        pump-delta(pump): {action-fluent, real, default = 0.0};
    };

    cpfs {

        // Intermediate fluents

        inflow(?n) = sum_{?un: node, ?p: pump} [DRAWS(?p, ?un, ?n) * pump-flow(?p)];
        outflow(?n) = sum_{?dn: node, ?p: pump} [DRAWS(?p, ?n, ?dn) * pump-flow(?p)];
        pump-hz-variance(?p) = max[0.0, Normal(pump-hz(?p), 5)];

        // State and action fluents

        // For now, we'll assume the pump RPM changes instantaneously and deterministically
        // The reality is that the pump would take some time to adjust its speed but that's for later
        pump-hz'(?p) = 
            pump-hz-variance(?p) + pump-delta(?p);

        // TODO: in-pressure'(?un, ?dn)
        // TODO: out-pressure'(?un, ?dn)

        pump-flow'(?p) = 
            switch(PUMP-TYPE(?p)) {
                case @pd:
                    // max[0.0, Normal(pump-hz'(?p) * PUMP-DISPLACEMENT(?p), FLOW-VARIANCE)],
                    pump-hz'(?p) * PUMP-DISPLACEMENT(?p) / 60,
                // Since we don't have pressure implemented (yet), we'll treat DP and CF pump flow the same.
                case @cf:
                    pump-hz'(?p) * PUMP-DISPLACEMENT(?p) / 60
            };

        holding'(?n) = holding(?n) + ( inflow(?n) - outflow(?n) ) * POLLING-RATE;
        
        // TODO: pressure-obs(?s)
        // flow-obs(?p) = if (exists_{?s: sensor-flow} [SENSOR-FLOW(?s, ?p)]) then 1 else 0;
        // level-obs(?n) = if (exists_{?s: sensor-level} [SENSOR-LEVEL(?s, ?n)]) then 1 else 0;

    };

    reward = 
        //sum_{?p: pump} [HAS-TARGET-FLOW(?p) * (abs[pump-flow'(?p) - TARGET-FLOW(?p)] <= FLOW-THRESHOLD) * abs[pump-flow'(?p) - TARGET-FLOW(?p)]]
        //+ sum_{?n: node} [HAS-TARGET-LEVEL(?n) * (abs[(holding'(?n) / CAPACITY(?n)) - TARGET-LEVEL(?n)] <= LEVEL-THRESHOLD) * abs[(holding'(?n) / CAPACITY(?n)) - TARGET-LEVEL(?n)]];

        sum_{?p: pump} [HAS-TARGET-FLOW(?p) * abs[pump-flow'(?p) - TARGET-FLOW(?p)] * FLOW-PENALTY]
        + sum_{?n: node} [HAS-TARGET-LEVEL(?n) * abs[(holding'(?n) / CAPACITY(?n) - TARGET-LEVEL(?n))] * LEVEL-PENALTY];


        //sum_{?sf: sensor-flow, ?p: pump} [
        //    ( HAS-TARGET-FLOW(?sf) ^ SENSOR-FLOW(?sf, ?p) ) 
        //    * ( pow[abs[pump-flow'(?p) - TARGET-FLOW(?sf)], 2] * FLOW-PENALTY )
        //]
        //+ sum_{?sl: sensor-level, ?n: node} [
        //    ( HAS-TARGET-LEVEL(?sl) ^ SENSOR-LEVEL(?sl, ?n) ) 
        //    * ( pow[abs[(holding'(?n) / CAPACITY(?n)) - TARGET-LEVEL(?sl)], 2] * LEVEL-PENALTY )
        //];

	state-invariants {

        // If a pump is drawing fluid from A to B, then A and B must be connected.
        forall_{?p: pump, ?un: node, ?dn: node} [DRAWS(?p, ?un, ?dn) => CONNECTED(?un, ?dn)];
        
            // SINGLE-ASSIGNMENT CONSTRAINTS
        // Enforce single-assignment of pumps to arcs.
        forall_{?p: pump, ?un: node, ?dn: node} 
            [DRAWS(?p, ?un, ?dn) => ( forall_{?un1: node, ?dn1: node} 
                [(?un ~= ?un1 | ?dn ~= ?dn1) => ~DRAWS(?p, ?un1, ?dn1)] )];

        // Enforce single-assignment of flow sensors to pumps.
        //forall_{?fs: sensor-flow, ?p1: pump, ?p2: pump} 
        //    [(?p1 ~= ?p2) => (SENSOR-FLOW(?fs, ?p1) => ~SENSOR-FLOW(?fs, ?p2))];

        // Enforce single-assignment of level sensors to nodes.
        //forall_{?ls: sensor-level, ?n1: node, ?n2: node} 
        //    [(?n1 ~= ?n2) => (SENSOR-LEVEL(?ls, ?n1) => ~SENSOR-LEVEL(?ls, ?n2))];

        //forall_{?n: node} [(sum_{?p: pump} [(SOURCE(?p, ?n) * pump-flow(?p))
        //    + (sum_{?un: node} [DRAWS(?p, ?un, ?n) * pump-flow(?p)]) 
        //    ]) * POLLING-RATE <= CAPACITY(?n)];
        //forall_{?n: node} [(sum_{?p: pump} [(SINK(?n, ?p) * pump-flow(?p))
        //    + (sum_{?dn: node} [DRAWS(?p, ?n, ?dn) * pump-flow(?p)])
        //    ]) * POLLING-RATE <= CAPACITY(?n)];
        //forall_{?n: node} [(sum_{?p: pump} [( (SINK(?n, ?p) - SOURCE(?p, ?n)) * pump-flow(?p) )
        //    + (sum_{?dn: node} [DRAWS(?p, ?n, ?dn) * pump-flow(?p)])
        //    - (sum_{?un: node} [DRAWS(?p, ?un, ?n) * pump-flow(?p)]) 
        //    ]) * POLLING-RATE <= holding(?n)];

        forall_{?n: node} [CAPACITY(?n) > 0.0]; 
        forall_{?n: node} [holding(?n) >= 0.0];
        forall_{?n: node} [holding(?n) <= CAPACITY(?n)];

        forall_{?p: pump} [pump-hz(?p) >= 0.0];
        forall_{?p: pump} [pump-flow(?p) >= 0.0];
	};

    action-preconditions {
        forall_{?p: pump} [abs[pump-delta(?p)] <= PUMP-MAX-DELTA];
	};


}